#include <stdarg.h>
#include <unistd.h>
#include <limits.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//https://pythontutor.com/visualize.html#code=%23include%20%3Cstdarg.h%3E%0A%23include%20%3Cunistd.h%3E%0A%23include%20%3Climits.h%3E%0A%23include%20%3Cstdbool.h%3E%0A%23include%20%3Cstdio.h%3E%0A%23include%20%3Cstdlib.h%3E%0A%23include%20%3Cstring.h%3E%0A%0Atypedef%20struct%20s_stack_node%0A%7B%20%20%0A%20%20%20%20long%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20number%3B%0A%20%20%20%20struct%20s_stack_node%20%20%20%20%20*target_node%3B%20%20%0A%20%20%20%20struct%20s_stack_node%20%20%20%20%20*next%3B%20%20%0A%20%20%20%20struct%20s_stack_node%20%20%20%20%20*prev%3B%0A%7D%20t_stack_node%3B%0A%0Avoid%20%20%20%20ft_free_table%28char%20**argv%29%0A%7B%0A%20%20%20%20int%20%20%20%20i%3B%0A%0A%20%20%20%20i%20%3D%200%3B%0A%20%20%20%20if%20%28NULL%20%3D%3D%20argv%20%7C%7C%20NULL%20%3D%3D%20*argv%29%0A%20%20%20%20%20%20%20%20return%20%3B%0A%20%20%20%20while%20%28argv%5Bi%5D%29%0A%20%20%20%20%20%20%20%20free%28argv%5Bi%2B%2B%5D%29%3B%0A%20%20%20%20free%28argv%29%3B%0A%7D%0A%0Avoid%20%20%20%20ft_free_stack%28t_stack_node%20**stack%29%0A%7B%0A%20%20%20%20t_stack_node%20%20%20%20*tmp%3B%0A%20%20%20%20t_stack_node%20%20%20%20*current%3B%0A%0A%20%20%20%20if%20%28NULL%20%3D%3D%20stack%29%0A%20%20%20%20%20%20%20%20return%20%3B%0A%20%20%20%20current%20%3D%20*stack%3B%0A%20%20%20%20while%20%28current%29%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20tmp%20%3D%20current-%3Enext%3B%0A%20%20%20%20%20%20%20%20free%28current%29%3B%0A%20%20%20%20%20%20%20%20current%20%3D%20tmp%3B%0A%20%20%20%20%7D%0A%20%20%20%20*stack%20%3D%20NULL%3B%0A%7D%0A%0Avoid%20ft_stack_%28long%20n,%20t_stack_node%20**stack%29%0A%7B%0A%20%20%20%20t_stack_node%20*node%3B%0A%20%20%20%20t_stack_node%20*last_node%3B%0A%0A%20%20%20%20node%20%3D%20%28t_stack_node%20*%29malloc%28sizeof%28t_stack_node%29%29%3B%0A%20%20%20%20if%20%28!node%29%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20return%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20node-%3Enumber%20%3D%20n%3B%0A%20%20%20%20node-%3Enext%20%3D%20NULL%3B%0A%20%20%20%20node-%3Eprev%20%3D%20NULL%3B%0A%0A%20%20%20%20if%20%28*stack%20%3D%3D%20NULL%29%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20*stack%20%3D%20node%3B%0A%20%20%20%20%7D%0A%20%20%20%20else%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20last_node%20%3D%20*stack%3B%0A%20%20%20%20%20%20%20%20while%20%28last_node-%3Enext%29%0A%20%20%20%20%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20last_node%20%3D%20last_node-%3Enext%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20last_node-%3Enext%20%3D%20node%3B%0A%20%20%20%20%20%20%20%20node-%3Eprev%20%3D%20last_node%3B%0A%20%20%20%20%7D%0A%7D%0A%0Aint%20ft_reapt%28t_stack_node%20*node,%20int%20nbr%29%0A%7B%0A%20%20%20%20if%20%28NULL%20%3D%3D%20node%29%0A%20%20%20%20%20%20%20%20return%20%280%29%3B%0A%20%20%20%20while%20%28node%29%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20if%20%28node-%3Enumber%20%3D%3D%20nbr%29%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20%281%29%3B%0A%20%20%20%20%20%20%20%20node%20%3D%20node-%3Enext%3B%0A%20%20%20%20%7D%0A%20%20%20%20return%20%280%29%3B%0A%7D%0A%0Avoid%20ft_stack_init%28t_stack_node%20**stack,%20char%20**argv%29%0A%7B%0A%20%20%20%20long%20n%3B%20%0A%20%20%20%20int%20i%3B%0A%20%20%20%20t_stack_node%20*node%3B%0A%0A%20%20%20%20i%20%3D%200%3B%0A%20%20%20%20while%20%28argv%5Bi%5D%29%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20n%20%3D%20atol%28argv%5Bi%5D%29%3B%0A%20%20%20%20%20%20%20%20%20if%28ft_reapt%28*stack,%20n%29%29%0A%20%20%20%20%20%20%20%20%20%20%20%20return%3B%0A%20%20%20%20%20%20%20%20ft_stack_%28n,%20stack%29%3B%0A%20%20%20%20%20%20%20%20i%2B%2B%3B%0A%20%20%20%20%7D%0A%20%20%20%20ft_free_table%28argv%29%3B%0A%7D%0A%0Aint%20main%28%29%0A%7B%0A%20%20%20%20t_stack_node%20*a%20%3D%20NULL%3B%0A%20%20%20%20char%20**dynamic_argv%3B%0A%20%20%20%20int%20i%3B%0A%0A%20%20%20%20//%20Alokowanie%20pami%C4%99ci%20dla%204%20wska%C5%BAnik%C3%B3w%20na%20%C5%82a%C5%84cuchy%20znak%C3%B3w%0A%20%20%20%20dynamic_argv%20%3D%20malloc%284%20*%20sizeof%28char%20*%29%29%3B%0A%0A%20%20%20%20//%20Alokowanie%20i%20przypisywanie%20warto%C5%9Bci%20do%20dynamicznej%20tablicy%0A%20%20%20%20dynamic_argv%5B0%5D%20%3D%20malloc%283%20*%20sizeof%28char%29%29%3B%20//%20%2242%22%0A%20%20%20%20dynamic_argv%5B1%5D%20%3D%20malloc%285%20*%20sizeof%28char%29%29%3B%20//%20%221337%22%0A%20%20%20%20dynamic_argv%5B2%5D%20%3D%20malloc%283%20*%20sizeof%28char%29%29%3B%20//%20%2256%22%0A%20%20%20%20dynamic_argv%5B3%5D%20%3D%20NULL%3B%0A%0A%20%20%20%20strcpy%28dynamic_argv%5B0%5D,%20%2242%22%29%3B%0A%20%20%20%20strcpy%28dynamic_argv%5B1%5D,%20%221337%22%29%3B%0A%20%20%20%20strcpy%28dynamic_argv%5B2%5D,%20%2256%22%29%3B%0A%0A%20%20%20%20ft_stack_init%28%26a,%20dynamic_argv%29%3B%0A%0A%20%20%20%20t_stack_node%20*temp%20%3D%20a%3B%0A%20%20%20%20while%20%28temp%29%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20printf%28%22%25ld%5Cn%22,%20temp-%3Enumber%29%3B%0A%20%20%20%20%20%20%20%20temp%20%3D%20temp-%3Enext%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20ft_free_stack%28%26a%29%3B%0A%0A%20%20%20%20return%200%3B%0A%7D&cumulative=false&heapPrimitives=nevernest&mode=edit&origin=opt-frontend.js&py=c_gcc9.3.0&rawInputLstJSON=%5B%5D&textReferences=false

typedef struct s_stack_node
{  
    long                    number;
    struct s_stack_node     *target_node;  
    struct s_stack_node     *next;  
    struct s_stack_node     *prev;
} t_stack_node;

void    ft_free_table(char **argv)
{
    int    i;

    i = 0;
    if (NULL == argv || NULL == *argv)
        return ;
    while (argv[i])
        free(argv[i++]);
    free(argv);
}

void    ft_free_stack(t_stack_node **stack)
{
    t_stack_node    *tmp;
    t_stack_node    *current;

    if (NULL == stack)
        return ;
    current = *stack;
    while (current)
    {
        tmp = current->next;
        free(current);
        current = tmp;
    }
    *stack = NULL;
}

void ft_stack_(long n, t_stack_node **stack)
{
    t_stack_node *a;
    t_stack_node *last_a;

    // Alokacja pamięci dla nowego węzła
    a = (t_stack_node *)malloc(sizeof(t_stack_node));
    if (!a)
    {
        // Obsługa błędu alokacji, jeśli to konieczne
        return;
    }

    // Inicjalizacja nowego węzła
    a->number = n;
    a->next = NULL;
    a->prev = NULL;

    // Jeśli stos jest pusty, ustaw nowy węzeł jako pierwszy element
    if (*stack == NULL)
    {
        *stack = a;
    }
    else
    {
        // Znajdź ostatni węzeł w stosie
        last_a = *stack;
        while (last_a->next)
        {
            last_a = last_a->next;
        }
        
        // Dołącz nowy węzeł na końcu stosu
        last_a->next = a;
        a->prev = last_a;
    }
}

int ft_reapt(t_stack_node *node, int nbr)
{
    if (NULL == node)
        return (0);
    while (node)
    {
        if (node->number == nbr)
            return (1);
        node = node->next;
    }
    return (0);
}

void ft_stack_init(t_stack_node **stack, char **argv)
{
    long n; 
    int i;
    t_stack_node *node;

    i = 0;
    while (argv[i])
    {
        n = atol(argv[i]);
         if(ft_reapt(*stack, n))
            return;
        ft_stack_(n, stack);
        i++;
    }
    ft_free_table(argv);
}

int main()
{
    t_stack_node *a = NULL;
    char **dynamic_argv;
    int i;

    // Alokowanie pamięci dla 4 wskaźników na łańcuchy znaków
    dynamic_argv = malloc(4 * sizeof(char *));

    // Alokowanie i przypisywanie wartości do dynamicznej tablicy
    dynamic_argv[0] = malloc(3 * sizeof(char)); // "42"
    dynamic_argv[1] = malloc(5 * sizeof(char)); // "1337"
    dynamic_argv[2] = malloc(3 * sizeof(char)); // "56"
    dynamic_argv[3] = NULL;

    strcpy(dynamic_argv[0], "42");
    strcpy(dynamic_argv[1], "1337");
    strcpy(dynamic_argv[2], "56");

    ft_stack_init(&a, dynamic_argv);

    t_stack_node *temp = a;
    while (temp)
    {
        printf("%ld\n", temp->number);
        temp = temp->next;
    }

    ft_free_stack(&a);

    return 0;
}